# [Recap](https://beautifulracket.com/stacker/recap.html)

## Notes

* Langs in Racket: source-to-source compilers

* Langs in Racket get Racket's capabilities for free

* Reader converts new lang source into parenth'd forms (`S-expressions`)

  * Must provide `read-syntax` function

  * Must package S-expressions as module syntax object

  * Racket replaces source code with this module code

* Expander determines how these S-expressions correspond to real Racket exprs

  * Must ensure every `identifier` has a `binding`

  * Must provide `#%module-begin` macro (Racket takes code from inside module
    expression and passes it to this macro)

  * Must provide new Racket code, again packaged as syntax object

  * Racket replaces the module expression generated by the reader with this new
    code

* Macros are like functions but run at compile time to copy and rewrite code

* Syntax object can hold a reference to the lexical context at a certain point
  in the program (`#'` prefix turns any code into a syntax object, by
  converting it into a datum and capturing its lexical context)
